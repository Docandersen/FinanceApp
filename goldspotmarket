# GoldPulse: Shortâ€‘term Gold Trend Analyzer (Streamlit)
# ---------------------------------------------------
# Features
# - Pulls gold spot (XAUUSD) and futures (COMEX GC) data via yfinance
# - Optional Alpha Vantage FX intraday for XAU/USD (set ALPHAVANTAGE_API_KEY)
# - Adds macro drivers: US Dollar Index futures (DX) and 10Y yield (^TNX)
# - Feature engineering: returns, EMAs, RSI, Bollinger zâ€‘score, realized vol, macro deltas
# - Regime detection (KMeans) and Gradient Boosting classifier for nextâ€‘period direction
# - Walkâ€‘forward backtest and simple volatilityâ€‘targeted position sizing
# - Streamlit dashboard with charts & feature importances
#
# Quick start
#   pip install streamlit yfinance pandas numpy scikit-learn requests
#   streamlit run app.py
#
# Notes
# - Educational example. Not investment advice.
# - Live intraday via Alpha Vantage is optional to avoid rate limits in demo.

import os
import io
import math
import time
import json
from dataclasses import dataclass
from typing import Optional, Tuple

import requests
import numpy as np
import pandas as pd
import yfinance as yf

from sklearn.cluster import KMeans
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import StandardScaler

import streamlit as st

# -------------------------------
# Helpers
# -------------------------------

def _ema(s: pd.Series, span: int) -> pd.Series:
    return s.ewm(span=span, adjust=False).mean()

def rsi(series: pd.Series, length: int = 14) -> pd.Series:
    delta = series.diff()
    up = delta.clip(lower=0)
    down = -delta.clip(upper=0)
    roll_up = up.ewm(alpha=1/length, adjust=False).mean()
    roll_down = down.ewm(alpha=1/length, adjust=False).mean()
    rs = roll_up / (roll_down.replace(0, np.nan))
    rsi = 100 - (100 / (1 + rs))
    return rsi.fillna(50)

@dataclass
class DataBundle:
    price: pd.DataFrame  # columns: ['Close'] or ['Open','High','Low','Close','Volume']
    macro: pd.DataFrame  # aligned columns: ['DXY','TNX']

# -------------------------------
# Data fetchers
# -------------------------------

def fetch_yf(symbol: str, period: str = '2y', interval: str = '1h') -> pd.DataFrame:
    df = yf.download(symbol, period=period, interval=interval, auto_adjust=True, progress=False)
    # yfinance returns multiindex for multiple symbols; ensure single-level
    if isinstance(df.columns, pd.MultiIndex):
        df.columns = [c[0] for c in df.columns]
    return df.dropna()


def fetch_xau_yf(period: str, interval: str) -> pd.DataFrame:
    # Try spot XAUUSD; if unavailable, fall back to front-month futures GC=F
    for sym in ['XAUUSD=X', 'GC=F']:
        try:
            df = fetch_yf(sym, period=period, interval=interval)
            if not df.empty:
                df['Symbol'] = sym
                return df
        except Exception:
            continue
    return pd.DataFrame()


def fetch_dxy_tnx(period: str, interval: str) -> pd.DataFrame:
    # Dollar index futures and 10Y yield index
    dxy = fetch_yf('DX=F', period=period, interval=interval)
    tnx = fetch_yf('^TNX', period=period, interval=interval)
    out = pd.DataFrame(index=dxy.index.union(tnx.index))
    if not dxy.empty:
        out['DXY'] = dxy['Close']
    if not tnx.empty:
        out['TNX'] = tnx['Close'] / 100.0  # ^TNX is yield*10
    return out.dropna()


def fetch_alpha_vantage_xau(interval: str = '15min', output_size: str = 'compact') -> pd.DataFrame:
    key = os.getenv('ALPHAVANTAGE_API_KEY')
    if not key:
        return pd.DataFrame()
    url = 'https://www.alphavantage.co/query'
    params = {
        'function': 'FX_INTRADAY',
        'from_symbol': 'XAU',
        'to_symbol': 'USD',
        'interval': interval,
        'outputsize': output_size,
        'datatype': 'json',
        'apikey': key,
    }
    r = requests.get(url, params=params, timeout=30)
    r.raise_for_status()
    js = r.json()
    # Payload key is like 'Time Series FX (15min)'
    k = [k for k in js.keys() if k.startswith('Time Series')]
    if not k:
        return pd.DataFrame()
    ts = pd.DataFrame(js[k[0]]).T
    ts.index = pd.to_datetime(ts.index)
    ts = ts.rename(columns={
        '1. open': 'Open', '2. high': 'High', '3. low': 'Low', '4. close': 'Close'
    }).sort_index()
    return ts.astype(float)


# -------------------------------
# Feature engineering
# -------------------------------

def make_features(price: pd.DataFrame, macro: pd.DataFrame, horizon_steps: int = 1) -> Tuple[pd.DataFrame, pd.Series]:
    df = price[['Close']].copy()
    df['ret_1'] = df['Close'].pct_change()
    df['ema_20'] = _ema(df['Close'], 20)
    df['ema_50'] = _ema(df['Close'], 50)
    df['ema_200'] = _ema(df['Close'], 200)
    df['ema_ratio'] = df['ema_20'] / df['ema_50'] - 1
    df['rsi_14'] = rsi(df['Close'], 14)
    roll = df['Close'].rolling(20)
    df['bb_z'] = (df['Close'] - roll.mean()) / (roll.std(ddof=0) + 1e-9)
    # realized volatility (annualized) using hourly/daily scaling guess based on index freq
    step_per_year = 252 if df.index.freq is not None and df.index.freq.n in ['D'] else 24*252
    df['rv'] = df['ret_1'].rolling(20).std(ddof=0) * math.sqrt(step_per_year)
    # Macro joins
    feat = df.join(macro.reindex(df.index).ffill())
    # Macro deltas
    feat['dxy_ret_1'] = feat['DXY'].pct_change()
    feat['tnx_chg'] = feat['TNX'].diff()
    # Targets: future return direction
    y = feat['Close'].pct_change(horizon_steps).shift(-horizon_steps)
    y = (y > 0).astype(int)
    X = feat.drop(columns=['Close'])
    X = X.replace([np.inf, -np.inf], np.nan).dropna()
    y = y.reindex(X.index)
    return X, y


# -------------------------------
# Modeling + backtest (simple walkâ€‘forward)
# -------------------------------

def walk_forward_backtest(X: pd.DataFrame, y: pd.Series, split_ratio: float = 0.7, threshold: float = 0.55):
    n = len(X)
    split = int(n * split_ratio)
    X_train, y_train = X.iloc[:split], y.iloc[:split]
    X_test, y_test = X.iloc[split:], y.iloc[split:]

    scaler = StandardScaler()
    X_train_s = scaler.fit_transform(X_train)
    X_test_s = scaler.transform(X_test)

    model = GradientBoostingClassifier(random_state=42)
    model.fit(X_train_s, y_train)
    proba = model.predict_proba(X_test_s)[:, 1]
    pred = (proba >= threshold).astype(int)

    acc = accuracy_score(y_test, pred)

    # Strategy: long 1 unit when proba>=threshold, else flat
    ret = X_test.index.to_series().sort_values()  # just to get index
    ret = y_test.copy().astype(float)
    # Use realized returns from target (approx) â€“ for demo purposes we map back to X's price changes
    # Compute price pct change on aligned index (requires access to original returns)
    # For simplicity, we reconstruct from the ret_1 feature present in X
    aligned = X_test.copy()
    if 'ret_1' in aligned.columns:
        rets = aligned['ret_1']
    else:
        rets = pd.Series(0.0, index=aligned.index)

    pos = pd.Series((proba >= threshold).astype(int), index=aligned.index)
    strat_rets = pos.shift(1).fillna(0) * rets  # enter next bar
    eq_curve = (1 + strat_rets).cumprod()

    # Volâ€‘adjusted stats
    ann_factor = 252 if (eq_curve.index[-1] - eq_curve.index[0]).days > 200 else 24*252
    sharpe = strat_rets.mean() / (strat_rets.std(ddof=0) + 1e-12) * math.sqrt(ann_factor)

    importances = pd.Series(model.feature_importances_, index=X.columns).sort_values(ascending=False)

    return {
        'model': model,
        'scaler': scaler,
        'acc': acc,
        'proba': pd.Series(proba, index=X_test.index),
        'pred': pd.Series(pred, index=X_test.index),
        'eq_curve': eq_curve,
        'strat_rets': strat_rets,
        'importances': importances,
    }


# -------------------------------
# Streamlit UI
# -------------------------------

def main():
    st.set_page_config(page_title='GoldPulse â€” shortâ€‘term gold trend', layout='wide')
    st.title('ðŸŸ¡ GoldPulse â€” shortâ€‘term gold trend analyzer')
    st.markdown('Educational demo for analyzing **international spot gold** and **shortâ€‘term trends** with macro drivers. Not investment advice.')

    col1, col2, col3 = st.columns(3)
    with col1:
        period = st.selectbox('History window', ['6mo','1y','2y','5y'], index=1)
    with col2:
        interval = st.selectbox('Bar interval', ['15m','30m','1h','1d'], index=2)
    with col3:
        horizon = st.selectbox('Prediction horizon', ['next bar','next 2 bars','next 4 bars'], index=0)
        horizon_steps = [1,2,4][['next bar','next 2 bars','next 4 bars'].index(horizon)]

    use_av = st.checkbox('Use Alpha Vantage intraday (requires ALPHAVANTAGE_API_KEY)', value=False)

    with st.spinner('Downloading market dataâ€¦'):
        if use_av:
            price = fetch_alpha_vantage_xau(interval='15min' if interval!='1d' else '60min')
            if price.empty:
                st.warning('Alpha Vantage returned no data; falling back to Yahoo Finance.')
                price = fetch_xau_yf(period=period, interval=interval)
        else:
            price = fetch_xau_yf(period=period, interval=interval)
        macro = fetch_dxy_tnx(period=period, interval=interval)

    if price.empty or macro.empty:
        st.error('Could not load price or macro data. Try a different interval/period.')
        st.stop()

    # Align
    idx = price.index.intersection(macro.index)
    price = price.reindex(idx).ffill()
    macro = macro.reindex(idx).ffill()

    st.subheader('Price')
    st.line_chart(price['Close'])

    X, y = make_features(price, macro, horizon_steps=horizon_steps)

    if len(X) < 300:
        st.warning('Not enough data after feature engineering; increase history window.')
        st.stop()

    threshold = st.slider('Long signal probability threshold', 0.5, 0.7, 0.55, 0.01)

    results = walk_forward_backtest(X, y, split_ratio=0.7, threshold=threshold)

    c1, c2 = st.columns([2,1])
    with c1:
        st.subheader('Equity curve (demo strategy)')
        st.line_chart(results['eq_curve'])
    with c2:
        st.metric('Outâ€‘ofâ€‘sample accuracy', f"{results['acc']*100:.1f}%")
        st.metric('Approx. Sharpe (demo)', f"{results['strat_rets'].mean() / (results['strat_rets'].std(ddof=0)+1e-12) * math.sqrt(252):.2f}")

    st.subheader('Feature importances')
    st.bar_chart(results['importances'].head(12))

    # Regime detection
    st.subheader('Market regimes (unsupervised)')
    feats_for_kmeans = X[['ret_1','ema_ratio','rsi_14','bb_z','rv','dxy_ret_1','tnx_chg']].dropna()
    km = KMeans(n_clusters=3, random_state=42, n_init='auto')
    regs = pd.Series(km.fit_predict(StandardScaler().fit_transform(feats_for_kmeans)), index=feats_for_kmeans.index, name='regime')
    regime_df = pd.concat([price['Close'].reindex(regs.index), regs], axis=1).dropna()
    st.line_chart(regime_df.pivot(columns='regime', values='Close').ffill())

    st.caption('Data via Yahoo Finance (spot/futures), optional Alpha Vantage for FX intraday; macro via Yahoo Finance (^TNX) and DX futures.')

if __name__ == '__main__':
    main()
